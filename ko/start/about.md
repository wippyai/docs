# Wippy 소개

Wippy는 실행 중 변경이 필요한 소프트웨어를 위한 에이전틱 플랫폼이자 런타임입니다. 자동화 시스템, AI 에이전트, 플러그인 아키텍처처럼 핵심 로직은 한 번만 개발하고 이후에는 재빌드나 재배포 없이 계속 적응해 나가야 하는 애플리케이션에 적합합니다.

액터 모델 기반으로 동작합니다. 코드는 메시지로 통신하는 격리된 프로세스에서 실행되며, 각 프로세스는 자체 상태를 관리합니다. 무언가 실패해도 해당 프로세스만 영향받습니다. 슈퍼비전 트리가 장애 발생 시 프로세스를 자동으로 재시작하여 복구합니다.

```lua
local worker = process.spawn("app.workers:handler", "app:processes")
process.send(worker, "task", {id = 1, data = payload})
process.monitor(worker)
```

설정은 중앙 레지스트리에 저장되며, 변경 사항은 이벤트로 전파됩니다. 설정 파일을 수정하면 실행 중인 프로세스가 이를 감지합니다. 시스템을 재시작하지 않고도 새 연결 추가, 동작 변경 등 필요한 조정이 가능합니다.

```lua
local db = registry.get("app.db:postgres")
local cache = registry.get("app.cache:redis")
```

결제 처리, 다단계 워크플로우, 장기 실행 에이전트 작업처럼 인프라 장애에도 반드시 완료되어야 하는 작업은 런타임이 자동으로 상태를 저장합니다. 서버가 중단되어도 워크플로우는 다른 머신에서 중단된 지점부터 재개됩니다.

전체 시스템은 단일 바이너리로 실행됩니다. 별도의 컨테이너 오케스트레이션이나 서비스 조율이 필요 없습니다. 바이너리 하나와 설정 파일 하나만 있으면 런타임이 나머지를 처리합니다.

## 배경

액터 모델은 1980년대부터 전화 교환기에 사용되어 온 Erlang에서 유래했습니다. 실패를 격리하고 빠르게 재시작하는 "let it crash" 철학도 그곳에서 비롯되었습니다. Go는 채널과 메시지 전달 방식이 동시성 코드를 읽기 쉽게 만든다는 것을 보여주었고, Temporal은 내구성 있는 워크플로우가 프레임워크와 싸우지 않고도 구현될 수 있음을 증명했습니다.

Wippy는 AI 에이전트가 실행 중에 인프라를 변경할 수 있어야 한다는 요구에서 시작되었습니다. 새로운 도구, 수정된 프롬프트, 다른 모델 등은 배포 주기를 기다릴 여유가 없습니다. 에이전트가 새로운 방식을 시도해야 할 때, 그 변경은 다음 릴리스가 아닌 몇 초 안에 반영되어야 합니다.

에이전트는 레지스트리에 접근할 수 있는 액터로 실행되므로, 코드를 생성하고 새 컴포넌트를 등록하고 자체 워크플로우를 조정하는 등의 변경을 스스로 수행할 수 있습니다. 충분한 권한이 주어지면 에이전트는 사람의 개입 없이 작동 방식을 개선할 수 있습니다. 시스템이 스스로를 발전시킬 수 있는 것입니다.
